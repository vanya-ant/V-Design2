{"ast":null,"code":"import 'firebase/compat/auth';\nimport { isPlatformServer } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport * as i2 from '@angular/fire/app-check';\nimport { ɵcacheInstance as _cacheInstance, ɵfirebaseAppFactory as _firebaseAppFactory, ɵlazySDKProxy as _lazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵapplyMixins as _applyMixins } from '@angular/fire/compat';\nimport { Subject, of, Observable, from, merge } from 'rxjs';\nimport { observeOn, switchMap, map, shareReplay, first, switchMapTo, subscribeOn, filter } from 'rxjs/operators';\nimport firebase from 'firebase/compat/app';\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\n// Export a null object with the same keys as firebase/compat/auth, so Proxy can work with proxy-polyfill in Internet Explorer\nconst proxyPolyfillCompat = {\n  name: null,\n  config: null,\n  emulatorConfig: null,\n  app: null,\n  applyActionCode: null,\n  checkActionCode: null,\n  confirmPasswordReset: null,\n  createUserWithEmailAndPassword: null,\n  currentUser: null,\n  fetchSignInMethodsForEmail: null,\n  isSignInWithEmailLink: null,\n  getRedirectResult: null,\n  languageCode: null,\n  settings: null,\n  onAuthStateChanged: null,\n  onIdTokenChanged: null,\n  sendSignInLinkToEmail: null,\n  sendPasswordResetEmail: null,\n  setPersistence: null,\n  signInAndRetrieveDataWithCredential: null,\n  signInAnonymously: null,\n  signInWithCredential: null,\n  signInWithCustomToken: null,\n  signInWithEmailAndPassword: null,\n  signInWithPhoneNumber: null,\n  signInWithEmailLink: null,\n  signInWithPopup: null,\n  signInWithRedirect: null,\n  signOut: null,\n  tenantId: null,\n  updateCurrentUser: null,\n  useDeviceLanguage: null,\n  useEmulator: null,\n  verifyPasswordResetCode: null\n};\nconst USE_EMULATOR = /*#__PURE__*/new InjectionToken('angularfire2.auth.use-emulator');\nconst SETTINGS = /*#__PURE__*/new InjectionToken('angularfire2.auth.settings');\nconst TENANT_ID = /*#__PURE__*/new InjectionToken('angularfire2.auth.tenant-id');\nconst LANGUAGE_CODE = /*#__PURE__*/new InjectionToken('angularfire2.auth.langugage-code');\nconst USE_DEVICE_LANGUAGE = /*#__PURE__*/new InjectionToken('angularfire2.auth.use-device-language');\nconst PERSISTENCE = /*#__PURE__*/new InjectionToken('angularfire.auth.persistence');\nconst ɵauthFactory = (app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence) => _cacheInstance(`${app.name}.auth`, 'AngularFireAuth', app.name, () => {\n  const auth = zone.runOutsideAngular(() => app.auth());\n  if (useEmulator) {\n    auth.useEmulator(...useEmulator);\n  }\n  if (tenantId) {\n    auth.tenantId = tenantId;\n  }\n  auth.languageCode = languageCode;\n  if (useDeviceLanguage) {\n    auth.useDeviceLanguage();\n  }\n  if (settings) {\n    for (const [k, v] of Object.entries(settings)) {\n      auth.settings[k] = v;\n    }\n  }\n  if (persistence) {\n    auth.setPersistence(persistence);\n  }\n  return auth;\n}, [useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence]);\nlet AngularFireAuth = /*#__PURE__*/(() => {\n  class AngularFireAuth {\n    /**\n     * Observable of authentication state; as of Firebase 4.0 this is only triggered via sign-in/out\n     */\n    authState;\n    /**\n     * Observable of the currently signed-in user's JWT token used to identify the user to a Firebase service (or null).\n     */\n    idToken;\n    /**\n     * Observable of the currently signed-in user (or null).\n     */\n    user;\n    /**\n     * Observable of the currently signed-in user's IdTokenResult object which contains the ID token JWT string and other\n     * helper properties for getting different data associated with the token as well as all the decoded payload claims\n     * (or null).\n     */\n    idTokenResult;\n    /**\n     * Observable of the currently signed-in user's credential, or null\n     */\n    credential;\n    constructor(options, name,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    platformId, zone, schedulers, useEmulator,\n    // can't use the tuple here\n    settings,\n    // can't use firebase.auth.AuthSettings here\n    tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {\n      const logins = new Subject();\n      const auth = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(() => zone.runOutsideAngular(() => import('firebase/compat/auth'))), map(() => _firebaseAppFactory(options, zone, name)), map(app => ɵauthFactory(app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence)), shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n      if (isPlatformServer(platformId)) {\n        this.authState = this.user = this.idToken = this.idTokenResult = this.credential = of(null);\n      } else {\n        // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth\n        //       (e.g, `import { auth } from 'firebase/compat/app'`) are getting an undefined auth object unexpectedly\n        //       as we're completely lazy. Let's eagerly load the Auth SDK here.\n        //       There could potentially be race conditions still... but this greatly decreases the odds while\n        //       we reevaluate the API.\n        auth.pipe(first()).subscribe();\n        const redirectResult = auth.pipe(switchMap(auth => auth.getRedirectResult().then(it => it, () => null)), keepUnstableUntilFirst, shareReplay({\n          bufferSize: 1,\n          refCount: false\n        }));\n        const authStateChanged = auth.pipe(switchMap(auth => new Observable(sub => ({\n          unsubscribe: zone.runOutsideAngular(() => auth.onAuthStateChanged(next => sub.next(next), err => sub.error(err), () => sub.complete()))\n        }))));\n        const idTokenChanged = auth.pipe(switchMap(auth => new Observable(sub => ({\n          unsubscribe: zone.runOutsideAngular(() => auth.onIdTokenChanged(next => sub.next(next), err => sub.error(err), () => sub.complete()))\n        }))));\n        this.authState = redirectResult.pipe(switchMapTo(authStateChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n        this.user = redirectResult.pipe(switchMapTo(idTokenChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n        this.idToken = this.user.pipe(switchMap(user => user ? from(user.getIdToken()) : of(null)));\n        this.idTokenResult = this.user.pipe(switchMap(user => user ? from(user.getIdTokenResult()) : of(null)));\n        this.credential = merge(redirectResult, logins,\n        // pipe in null authState to make credential zipable, just a weird devexp if\n        // authState and user go null to still have a credential\n        this.authState.pipe(filter(it => !it))).pipe(\n        // handle the { user: { } } when a user is already logged in, rather have null\n        // TODO handle the type corcersion better\n        map(credential => credential?.user ? credential : null), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      }\n      return _lazySDKProxy(this, auth, zone, {\n        spy: {\n          apply: (name, _, val) => {\n            // If they call a signIn or createUser function listen into the promise\n            // this will give us the user credential, push onto the logins Subject\n            // to be consumed in .credential\n            if (name.startsWith('signIn') || name.startsWith('createUser')) {\n              // TODO fix the types, the trouble is UserCredential has everything optional\n              val.then(user => logins.next(user));\n            }\n          }\n        }\n      });\n    }\n    static ɵfac = function AngularFireAuth_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AngularFireAuth)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(TENANT_ID, 8), i0.ɵɵinject(LANGUAGE_CODE, 8), i0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), i0.ɵɵinject(PERSISTENCE, 8), i0.ɵɵinject(i2.AppCheckInstances, 8));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: AngularFireAuth,\n      factory: AngularFireAuth.ɵfac,\n      providedIn: 'any'\n    });\n  }\n  return AngularFireAuth;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*#__PURE__*/_applyMixins(AngularFireAuth, [proxyPolyfillCompat]);\nlet AngularFireAuthModule = /*#__PURE__*/(() => {\n  class AngularFireAuthModule {\n    constructor() {\n      firebase.registerVersion('angularfire', VERSION.full, 'auth-compat');\n    }\n    static ɵfac = function AngularFireAuthModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AngularFireAuthModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: AngularFireAuthModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [AngularFireAuth]\n    });\n  }\n  return AngularFireAuthModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFireAuth, AngularFireAuthModule, LANGUAGE_CODE, PERSISTENCE, SETTINGS, TENANT_ID, USE_DEVICE_LANGUAGE, USE_EMULATOR, ɵauthFactory };\n//# sourceMappingURL=angular-fire-compat-auth.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}